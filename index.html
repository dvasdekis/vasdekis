<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vasdekis</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }

        #vanta-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #webgl-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: relative;
            z-index: 2;
            background: transparent;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <div id="vanta-background"></div>
    <div id="loading">Loading...</div>
    <canvas id="webgl-canvas"></canvas>

    <script>
        // Matrix Math Utilities
        function createMatrix4() {
            return new Float32Array(16);
        }

        function identity(matrix) {
            matrix[0] = 1; matrix[1] = 0; matrix[2] = 0; matrix[3] = 0;
            matrix[4] = 0; matrix[5] = 1; matrix[6] = 0; matrix[7] = 0;
            matrix[8] = 0; matrix[9] = 0; matrix[10] = 1; matrix[11] = 0;
            matrix[12] = 0; matrix[13] = 0; matrix[14] = 0; matrix[15] = 1;
            return matrix;
        }

        function perspective(matrix, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);

            matrix[0] = f / aspect;
            matrix[1] = 0;
            matrix[2] = 0;
            matrix[3] = 0;
            matrix[4] = 0;
            matrix[5] = f;
            matrix[6] = 0;
            matrix[7] = 0;
            matrix[8] = 0;
            matrix[9] = 0;
            matrix[10] = (far + near) * nf;
            matrix[11] = -1;
            matrix[12] = 0;
            matrix[13] = 0;
            matrix[14] = (2 * far * near) * nf;
            matrix[15] = 0;

            return matrix;
        }

        function translate(matrix, x, y, z) {
            matrix[12] += matrix[0] * x + matrix[4] * y + matrix[8] * z;
            matrix[13] += matrix[1] * x + matrix[5] * y + matrix[9] * z;
            matrix[14] += matrix[2] * x + matrix[6] * y + matrix[10] * z;
            matrix[15] += matrix[3] * x + matrix[7] * y + matrix[11] * z;
            return matrix;
        }

        function rotateY(matrix, angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const m00 = matrix[0], m01 = matrix[1], m02 = matrix[2], m03 = matrix[3];
            const m20 = matrix[8], m21 = matrix[9], m22 = matrix[10], m23 = matrix[11];

            matrix[0] = m00 * c + m20 * s;
            matrix[1] = m01 * c + m21 * s;
            matrix[2] = m02 * c + m22 * s;
            matrix[3] = m03 * c + m23 * s;
            matrix[8] = m20 * c - m00 * s;
            matrix[9] = m21 * c - m01 * s;
            matrix[10] = m22 * c - m02 * s;
            matrix[11] = m23 * c - m03 * s;

            return matrix;
        }

        function invert(out, a) {
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

            const b00 = a00 * a11 - a01 * a10;
            const b01 = a00 * a12 - a02 * a10;
            const b02 = a00 * a13 - a03 * a10;
            const b03 = a01 * a12 - a02 * a11;
            const b04 = a01 * a13 - a03 * a11;
            const b05 = a02 * a13 - a03 * a12;
            const b06 = a20 * a31 - a21 * a30;
            const b07 = a20 * a32 - a22 * a30;
            const b08 = a20 * a33 - a23 * a30;
            const b09 = a21 * a32 - a22 * a31;
            const b10 = a21 * a33 - a23 * a31;
            const b11 = a22 * a33 - a23 * a32;

            let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

            return out;
        }

        function transpose(out, a) {
            if (out === a) {
                let a01 = a[1], a02 = a[2], a03 = a[3];
                let a12 = a[6], a13 = a[7];
                let a23 = a[11];

                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a01;
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a02;
                out[9] = a12;
                out[11] = a[14];
                out[12] = a03;
                out[13] = a13;
                out[14] = a23;
            } else {
                out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
                out[8] = a[2]; out[9] = a[6]; out[10] = a[10]; out[11] = a[14];
                out[12] = a[3]; out[13] = a[7]; out[14] = a[11]; out[15] = a[15];
            }
            return out;
        }

        // Shaders
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;

            uniform mat4 u_modelMatrix;
            uniform mat4 u_viewMatrix;
            uniform mat4 u_projectionMatrix;
            uniform mat4 u_normalMatrix;

            varying vec3 v_normal;
            varying vec3 v_position;

            void main() {
                v_normal = mat3(u_normalMatrix) * a_normal;
                v_position = vec3(u_modelMatrix * vec4(a_position, 1.0));
                gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * vec4(a_position, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;

            uniform vec3 u_color;
            uniform vec3 u_lightPosition;
            uniform vec3 u_viewPosition;

            varying vec3 v_normal;
            varying vec3 v_position;

            void main() {
                // Ambient
                float ambientStrength = 0.3;
                vec3 ambient = ambientStrength * u_color;

                // Diffuse
                vec3 norm = normalize(v_normal);
                vec3 lightDir = normalize(u_lightPosition - v_position);
                float diff = max(dot(norm, lightDir), 0.0);
                vec3 diffuse = diff * u_color;

                // Specular
                float specularStrength = 0.8;
                vec3 viewDir = normalize(u_viewPosition - v_position);
                vec3 reflectDir = reflect(-lightDir, norm);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = specularStrength * vec3(1.0, 1.0, 1.0) * spec;

                vec3 result = ambient + diffuse + specular;
                gl_FragColor = vec4(result, 1.0);
            }
        `;

        // WebGL Helpers
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Error linking program:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Create V shape vertices with Normals
        function createVVertices() {
            const depth = 0.3;
            const scale = 0.6;

            const vertices = [];

            // Helper to add a triangle with its normal
            function addTriangle(p1, p2, p3) {
                // Calculate normal
                const u = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                const v = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];

                const nx = u[1] * v[2] - u[2] * v[1];
                const ny = u[2] * v[0] - u[0] * v[2];
                const nz = u[0] * v[1] - u[1] * v[0];

                // Normalize
                const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
                const normal = [nx / len, ny / len, nz / len];

                // Push vertices and normals
                vertices.push(
                    p1[0], p1[1], p1[2], normal[0], normal[1], normal[2],
                    p2[0], p2[1], p2[2], normal[0], normal[1], normal[2],
                    p3[0], p3[1], p3[2], normal[0], normal[1], normal[2]
                );
            }

            const points = [
                [-1.5 * scale, 1.0 * scale],   // 0: Top left outer
                [-0.5 * scale, 1.0 * scale],   // 1: Top left inner
                [-0.2 * scale, -1.0 * scale],  // 2: Bottom center left
                [1.5 * scale, 1.0 * scale],    // 3: Top right outer
                [0.5 * scale, 1.0 * scale],    // 4: Top right inner
                [0.2 * scale, -1.0 * scale],   // 5: Bottom center right
            ];

            // Front face (z = depth/2)
            addTriangle(
                [points[0][0], points[0][1], depth / 2],
                [points[2][0], points[2][1], depth / 2],
                [points[1][0], points[1][1], depth / 2]
            );
            addTriangle(
                [points[3][0], points[3][1], depth / 2],
                [points[4][0], points[4][1], depth / 2],
                [points[5][0], points[5][1], depth / 2]
            );

            // Back face (z = -depth/2) - reversed for culling
            addTriangle(
                [points[0][0], points[0][1], -depth / 2],
                [points[1][0], points[1][1], -depth / 2],
                [points[2][0], points[2][1], -depth / 2]
            );
            addTriangle(
                [points[3][0], points[3][1], -depth / 2],
                [points[5][0], points[5][1], -depth / 2],
                [points[4][0], points[4][1], -depth / 2]
            );

            // Side faces
            // Left arm outer
            addTriangle(
                [points[0][0], points[0][1], depth / 2],
                [points[0][0], points[0][1], -depth / 2],
                [points[2][0], points[2][1], depth / 2]
            );
            addTriangle(
                [points[0][0], points[0][1], -depth / 2],
                [points[2][0], points[2][1], -depth / 2],
                [points[2][0], points[2][1], depth / 2]
            );

            // Left arm inner
            addTriangle(
                [points[1][0], points[1][1], depth / 2],
                [points[2][0], points[2][1], depth / 2],
                [points[1][0], points[1][1], -depth / 2]
            );
            addTriangle(
                [points[1][0], points[1][1], -depth / 2],
                [points[2][0], points[2][1], depth / 2],
                [points[2][0], points[2][1], -depth / 2]
            );

            // Right arm outer
            addTriangle(
                [points[3][0], points[3][1], depth / 2],
                [points[5][0], points[5][1], depth / 2],
                [points[3][0], points[3][1], -depth / 2]
            );
            addTriangle(
                [points[3][0], points[3][1], -depth / 2],
                [points[5][0], points[5][1], depth / 2],
                [points[5][0], points[5][1], -depth / 2]
            );

            // Right arm inner
            addTriangle(
                [points[4][0], points[4][1], depth / 2],
                [points[4][0], points[4][1], -depth / 2],
                [points[5][0], points[5][1], depth / 2]
            );
            addTriangle(
                [points[4][0], points[4][1], -depth / 2],
                [points[5][0], points[5][1], -depth / 2],
                [points[5][0], points[5][1], depth / 2]
            );

            // Top left
            addTriangle(
                [points[0][0], points[0][1], depth / 2],
                [points[1][0], points[1][1], depth / 2],
                [points[0][0], points[0][1], -depth / 2]
            );
            addTriangle(
                [points[0][0], points[0][1], -depth / 2],
                [points[1][0], points[1][1], depth / 2],
                [points[1][0], points[1][1], -depth / 2]
            );

            // Top right
            addTriangle(
                [points[3][0], points[3][1], depth / 2],
                [points[3][0], points[3][1], -depth / 2],
                [points[4][0], points[4][1], depth / 2]
            );
            addTriangle(
                [points[3][0], points[3][1], -depth / 2],
                [points[4][0], points[4][1], -depth / 2],
                [points[4][0], points[4][1], depth / 2]
            );

            return new Float32Array(vertices);
        }

            // Main WebGL setup and animation
            function main() {
                console.log('Starting WebGL setup...');
                const canvas = document.getElementById('webgl-canvas');
                const gl = canvas.getContext('webgl', { alpha: true, premultipliedAlpha: false });

                if (!gl) {
                    alert('WebGL not supported');
                    return;
                }
                console.log('WebGL context created successfully');

                // Enable blending for transparency
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Set canvas size
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Create shaders and program
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
                const program = createProgram(gl, vertexShader, fragmentShader);

                if (!program) {
                    console.error('Failed to create shader program');
                    return;
                }

                // Get attribute and uniform locations
                const positionLocation = gl.getAttribLocation(program, 'a_position');
                const normalLocation = gl.getAttribLocation(program, 'a_normal');

                const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
                const viewMatrixLocation = gl.getUniformLocation(program, 'u_viewMatrix');
                const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
                const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
                const colorLocation = gl.getUniformLocation(program, 'u_color');
                const lightPosLocation = gl.getUniformLocation(program, 'u_lightPosition');
                const viewPosLocation = gl.getUniformLocation(program, 'u_viewPosition');

                // Create V geometry
                const vertices = createVVertices();
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                // Set up matrices
                const modelMatrix = createMatrix4();
                const viewMatrix = createMatrix4();
                const projectionMatrix = createMatrix4();
                const normalMatrix = createMatrix4();
                const tempMatrix = createMatrix4();

                // Set up view matrix
                identity(viewMatrix);
                translate(viewMatrix, 0, 0, -3);

                // Enable depth testing and face culling
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                gl.frontFace(gl.CCW);

                // Hide loading text
                document.getElementById('loading').style.display = 'none';

                // Animation loop
                let rotation = 0;
                function animate() {
                    rotation += 0.02;

                    // Clear canvas
                    gl.clearColor(0.0, 0.0, 0.0, 0.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    // Set up projection matrix
                    const aspect = canvas.width / canvas.height;
                    perspective(projectionMatrix, Math.PI / 4, aspect, 0.1, 100);

                    // Set up model matrix with rotation
                    identity(modelMatrix);
                    rotateY(modelMatrix, rotation);

                    // Calculate Normal Matrix (Inverse Transpose of Model)
                    invert(tempMatrix, modelMatrix);
                    transpose(normalMatrix, tempMatrix);

                    // Use shader program
                    gl.useProgram(program);

                    // Set uniforms
                    gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);
                    gl.uniformMatrix4fv(viewMatrixLocation, false, viewMatrix);
                    gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
                    gl.uniformMatrix4fv(normalMatrixLocation, false, normalMatrix);

                    gl.uniform3f(colorLocation, 0.0, 0.7, 1.0); // Bright blue color
                    gl.uniform3f(lightPosLocation, 2.0, 2.0, 5.0); // Light top right front
                    gl.uniform3f(viewPosLocation, 0.0, 0.0, 3.0); // Camera position

                    // Set up vertex attributes
                    const stride = 6 * 4; // 3 pos + 3 normal * 4 bytes

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                    gl.enableVertexAttribArray(positionLocation);
                    gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, stride, 0);

                    gl.enableVertexAttribArray(normalLocation);
                    gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, stride, 3 * 4);

                    // Draw the V
                    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 6);

                    requestAnimationFrame(animate);
                }

                animate();
            }

            // Create Storm/Lightning Background
            function createStormBackground() {
                const background = document.getElementById('vanta-background');
                const canvas = document.createElement('canvas');
                canvas.id = 'storm-canvas';
                canvas.style.position = 'absolute';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.zIndex = '0';
                background.innerHTML = ''; // Clear previous
                background.appendChild(canvas);

                const gl = canvas.getContext('webgl');
                if (!gl) return;

                const vertexShader = `
                attribute vec2 a_position;
                void main() {
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

                const fragmentShader = `
                precision mediump float;
                uniform vec2 iResolution;
                uniform float iTime;

                // Noise functions
                float hash(float n) { return fract(sin(n) * 43758.5453123); }
                float noise(vec3 x) {
                    vec3 p = floor(x);
                    vec3 f = fract(x);
                    f = f * f * (3.0 - 2.0 * f);
                    float n = p.x + p.y * 57.0 + 113.0 * p.z;
                    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                                   mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
                }

                // FBM for clouds
                float fbm(vec3 p) {
                    float f = 0.0;
                    f += 0.5000 * noise(p); p *= 2.02;
                    f += 0.2500 * noise(p); p *= 2.03;
                    f += 0.1250 * noise(p); p *= 2.01;
                    f += 0.0625 * noise(p);
                    return f;
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / iResolution.xy;
                    vec2 p = -1.0 + 2.0 * uv;
                    p.x *= iResolution.x / iResolution.y;

                    float time = iTime * 0.5;

                    // Dark stormy sky base
                    vec3 skyColor = vec3(0.05, 0.05, 0.1);
                    vec3 cloudColor = vec3(0.2, 0.2, 0.25);

                    // Moving clouds
                    float cover = fbm(vec3(p * 2.0 + vec2(time * 0.1, 0.0), time * 0.05));
                    cover = smoothstep(0.3, 0.8, cover);

                    vec3 col = mix(skyColor, cloudColor, cover);

                    // Lightning
                    float lightning = 0.0;
                    float t = iTime * 2.0;
                    // Random flashes
                    float flash = fract(sin(floor(t)) * 43758.5453);
                    if (flash > 0.95) {
                        // Localized flash or screen flash
                        float flashIntensity = smoothstep(0.95, 1.0, flash) * exp(-fract(t) * 10.0);
                        
                        // Lightning bolt shape (simplified as high noise value)
                        float bolt = smoothstep(0.6, 0.7, fbm(vec3(p * 10.0, time * 10.0)));
                        
                        lightning = flashIntensity * (0.5 + 0.5 * bolt);
                    }

                    // Add lightning color
                    col += vec3(0.8, 0.9, 1.0) * lightning;

                    // Darken edges (vignette)
                    float vig = 1.0 - length(p) * 0.5;
                    col *= vig;

                    gl_FragColor = vec4(col, 1.0);
                }
            `;

                function compileShader(source, type) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return null;
                    return shader;
                }

                const vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
                const fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);
                if (!vShader || !fShader) return;

                const program = gl.createProgram();
                gl.attachShader(program, vShader);
                gl.attachShader(program, fShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) return;

                const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                const uniforms = {
                    iResolution: gl.getUniformLocation(program, 'iResolution'),
                    iTime: gl.getUniformLocation(program, 'iTime')
                };
                const posLoc = gl.getAttribLocation(program, 'a_position');

                function resize() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }

                let startTime = Date.now();
                function animate() {
                    resize();
                    gl.useProgram(program);
                    gl.uniform2f(uniforms.iResolution, canvas.width, canvas.height);
                    gl.uniform1f(uniforms.iTime, (Date.now() - startTime) / 1000);

                    gl.enableVertexAttribArray(posLoc);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    requestAnimationFrame(animate);
                }

                window.addEventListener('resize', resize);
                animate();
            }

            window.addEventListener('load', function () {
                main();
                createStormBackground();
            });
    </script>
</body>

</html>